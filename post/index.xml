<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Sean Maloney</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on Sean Maloney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Jun 2016 11:58:01 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Some Title</title>
      <link>http://localhost:1313/2016/06/some-title/</link>
      <pubDate>Thu, 16 Jun 2016 11:58:01 -0500</pubDate>
      
      <guid>http://localhost:1313/2016/06/some-title/</guid>
      <description>

&lt;p&gt;Hello there&lt;/p&gt;

&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;

&lt;p&gt;foo bar&lt;/p&gt;

&lt;h3 id=&#34;header-3&#34;&gt;Header 3&lt;/h3&gt;

&lt;p&gt;Foo bar baz &lt;a href=&#34;www.google.com&#34;&gt;google&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How Are Things</title>
      <link>http://localhost:1313/2016/06/how-are-things/</link>
      <pubDate>Thu, 16 Jun 2016 11:06:52 -0500</pubDate>
      
      <guid>http://localhost:1313/2016/06/how-are-things/</guid>
      <description>

&lt;p&gt;My goal with building this demo app, was to give a small, yet realistic, look into how Elm allows us to accomplish daily tasks such as Http requests, routing, access, and more. It was important for me to structure it in the same way that we structure larger apps built for production, so that it could demonstrate more effectively how Elm can be used in a project.&lt;/p&gt;

&lt;p&gt;If you are interested in Elm, and want to get a feeling of how it could be built for your apps, this might be a good starting point. I’ve even wanted to add a single test to show how that could be done. But Elm being such a fun, predictable, opinionated, and fun (no mistake here, it deserves the double fun) to work with, I’ve ended up adding more and more tests.
Isn’t that yet another great sign for Elm? I was adding unit tests for a demo app, while we hardly added any unit tests for our Angular apps in production!&lt;/p&gt;

&lt;p&gt;I was holding myself from adding too many features, but I couldn’t resist polishing the existing ones, and adding lots of comments. With the compiler’s tough love and ever growing unit tests, any change was so easy it almost felt like cheating (and note that I rarely write “easy” or “trivial” on development issues).&lt;/p&gt;

&lt;p&gt;In general, at least for me, the great thing that Elm brings to the table is the reduced cognitive load. We don’t need to remember too much about our application every single second. This means we can concentrate on our current component and make sure it’s being wired in correctly to the entire application.&lt;/p&gt;

&lt;p&gt;With Elm-format we don’t even need to bother ourself with the file format; and along with the Atom integration on every save, we get consistent looking files.&lt;/p&gt;

&lt;h2 id=&#34;wiring-multiple-components&#34;&gt;WIRING MULTIPLE COMPONENTS&lt;/h2&gt;

&lt;p&gt;One of the questions I see people struggle with is how to have different components communicate with each other. I won’t get into depth here, but rather give some pointers to the code base. The gist of things is:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I Like To Write</title>
      <link>http://localhost:1313/2016/06/i-like-to-write/</link>
      <pubDate>Thu, 16 Jun 2016 10:46:48 -0500</pubDate>
      
      <guid>http://localhost:1313/2016/06/i-like-to-write/</guid>
      <description>&lt;p&gt;Let me not bury the lede: Samsung is acquiring Joyent, and Scott’s blog entry explains why we feel that this is such a good fit. As Joyent’s CTO, I wanted to offer my perspective and couch this acquisition in its broader historical context: the world’s largest consumer electronics company is acquiring a cloud computing pioneer; what’s going on here?&lt;/p&gt;

&lt;p&gt;A decade ago, one probably wouldn&amp;rsquo;t have guessed that the leaders in computing—which at the time included the survivors from the mainframe, minicomputer, workstation and personal computer revolutions—would become a search engine and an online bookstore. In this regard, cloud computing managed to achieve what previous computing revolutions did not: shift the wellspring of innovation away from those who merely design machines towards those who actually use them to solve their own problems. This shift—accelerated (if not outright facilitated) by the rise of open source—has left yesterday&amp;rsquo;s computing leaders displaced and disoriented; not only do they not have the solutions, but at a very real level they don&amp;rsquo;t even understand the problem: these legacy companies have never themselves meaningfully deployed on the cloud and (despite nodding along with cloud computing) they still really struggle to understand why anyone would do it that way.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>